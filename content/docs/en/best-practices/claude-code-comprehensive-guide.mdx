---
title: "Claude Code Complete Guide: 26 Core Features + Practical Tips (Must Collect!)"
description: "Claude Code is incredibly powerful! This comprehensive guide systematically breaks down 26 key features, from basic commands to context compression, from code assistance to GitHub automation, many uses go beyond traditional understanding of AI coding."
date: "2025-01-20"
author: "DeepToAI Team"
category: "best-practices"
language: "en"
tags: ["claude-code", "ai-programming", "development-tools", "practical-tips", "workflow", "best-practices"]
---

# Claude Code Complete Guide: 26 Core Features + Practical Tips (Must Collect!)

**Claude Code is incredibly powerful!!!**

I've been playing with Claude Code for some time, and it gets more addictive the more I use it. Not only is its programming capability extremely powerful, but it also brings a new paradigm for human-machine interaction. The longer I use it, the more I realize that it's far more than just an AI that writes code.

Jie Yi took the opportunity to systematically organize **26 key features** of Claude Code in development scenarios, from basic commands to context compression, from code assistance to GitHub automation, many uses **go beyond traditional understanding of AI coding**.

This article is both a comprehensive overview and a practical summary. Recommend collecting and slowly digesting.

**ðŸ”— Extended Reading:** [Claude Code Production Workflow Guide](/docs/en/best-practices/claude-code-production-workflow) | [99.9% AI-Driven Development](/docs/en/best-practices/99-percent-ai-development-comprehensive-guide)

The full content includes:

*   **Basic Operations**: Common commands, CLAUDE.md, image processing, installing IDE plugins, Safe YOLO mode
*   **Interaction & Session Management**: Clear chat context, shortcut operations, interrupt operations, resume historical sessions, context compression, custom commands
*   **Prompting & Thinking Strategies**: XML tag structured prompts, pre-activation, forced deep thinking, requirement analysis
*   **Software Development Practices**: Task decomposition, understanding project context, Linux command assistance
*   **Cost & Model Management**: Model switching, monitoring token costs, using ccusage consumption monitoring
*   **Advanced Features**: Running parallel Claude Code sessions using Git worktrees, MCP, Claude Code GitHub Action, using Claude as Unix-like programs

## **I. Basic Operations**

### **Install VS Code or Cursor Plugin**

Since Claude Code runs in the terminal, editing files is not very convenient, so you can install Claude Code plugins in IDEs (VS Code, Cursor, JetBrains, etc.), and after installation, you can quickly launch Claude Code. This enables collaborative work between the IDE and Claude Code.

![VS Code Plugin Installation](/images/claude-code-comprehensive-guide/vs-code-plugin.jpg)

**ðŸ”— Extended Reading:** [33 Claude Code Setup Tips](/docs/en/best-practices/claude-code-setup-tips)

### **Common Commands**

The following are the most important commands in daily Claude Code usage, recommend mastering them all:

| Command | Function | Example |
|---------|----------|---------|
| claude | Start interactive mode | claude |
| claude "task" | Run one-time task | claude "fix the build error" |
| claude -p "query" | Run one-time query, then exit | claude -p "explain this function" |
| claude -c | Continue recent conversation | claude -c |
| claude -r | Resume previous conversation | claude -r |
| claude commit | Create Git commit | claude commit |
| /clear | Clear conversation history | > /clear |
| /help | Show available commands | > /help |
| exit or Ctrl+C | Exit Claude Code | > exit |

### **CLAUDE.md File Management**

The Claude.md file is similar to Cursor's Rules file, specifying how AI generates code. You can specify code style, development environment, repository specifications, etc. in it.

Claude.md example:

```markdown
# Bash Commands  
- `npm run build`: Build project  
- `npm run typecheck`: Run type checking  

# Code Style  
- Use ES module syntax (`import/export`), not CommonJS (`require`)  
- Use destructuring imports whenever possible (e.g.: `import { foo } from 'bar'`)  

# Workflow  
- After completing a series of code changes, must perform type checking  
- For performance reasons, prioritize running individual tests over the entire test suite
```

You can create multiple `CLAUDE.md` files in project root and subdirectories to provide personalized configuration for each context.

| File Path | Purpose |
|-----------|---------|
| Project Root / CLAUDE.md | Team-shared project-level configuration, committed to Git for all members |
| Project Root / CLAUDE.local.md | Personal local override configuration, usually added to .gitignore to avoid affecting others |
| Parent Directory / CLAUDE.md | Upper-level configuration automatically inherited in Monorepo structure (recursive upward search) |
| Subdirectory / CLAUDE.md | Independent configuration for specific submodules/features (loaded with priority over parent configuration) |
| ~/.claude/CLAUDE.md | User global default configuration, applicable to baseline settings for all Claude sessions |

You can also input `#` in conversations to dynamically add content to CLAUDE.md

![Claude MD Dynamic Addition](/images/claude-code-comprehensive-guide/claude-md-dynamic-add.jpg)

**ðŸ”— Extended Reading:** [CCPM Claude Code Project Manager](/docs/en/tools/ccpm-claude-code-project-manager)

### **Image Processing**

Claude Code supports pasting images, allowing Claude to complete tasks based on images, such as: "Design a webpage based on the image" or "Analyze error screenshot causes".

Uploaded images won't be displayed directly, but will be replaced with `[Image #id]` placeholders.

![Placeholder Images](/images/claude-code-comprehensive-guide/image-placeholder.jpg)

### **Safe YOLO Mode**

For safety, Claude Code by default requests your consent when executing some commands. To achieve more convenient automation, you can set Safe YOLO mode.

When starting Claude, execute the following command:

`claude --dangerously-skip-permissions`

After executing this, Claude will **automatically skip all permission confirmations**, no need for manual approval. This is very convenient for repetitive tasks.

## **II. Interaction & Session Management**

### **Clear Chat Context**

Use **`/clear`** to clear chat context, avoiding accumulated excessive historical information affecting efficiency.

![Clear Context](/images/claude-code-comprehensive-guide/clear-context.jpg)

**ðŸ”— Extended Reading:** [Compounding Engineering Framework](/docs/en/advanced/compounding-engineering)

### **Shortcut Operations**

*   `/` View commands
*   Arrow keys browse history
*   `Tab` completion
*   `Option+Enter` line break
*   `Ctrl+C` exit, etc.

### **Interrupt Operations**

When entering wrong commands, press `ESC` key to immediately stop AI's current task.

![Interrupt Operations](/images/claude-code-comprehensive-guide/interrupt-operation.jpg)

### **Resume Historical Sessions**

At startup, execute `claude -c` to continue the last conversation

Execute `claude -r` to select and continue historical conversations. If you've already opened a conversation, you can also input `/resume` to switch to other sessions.

![Resume History](/images/claude-code-comprehensive-guide/resume-history.jpg)

### **Context Compression**

Claude Code provides `/compact`, which **compresses conversation history**, keeping only context summaries to reduce token usage.

![Compact Context](/images/claude-code-comprehensive-guide/compact-context.jpg)

This way Claude won't get stuck or drift off topic due to overly cluttered context.

### **Custom Commands**

```markdown
- User-level commands: `~/.claude/commands/`, prefix `/user:`.
- Project-level commands: `.claude/commands/`, prefix `/project:`.
- Example: After creating `optimize.md` file, input `/project:optimize` to automatically execute "analyze performance and suggest optimizations".
```

If you have frequently used workflows, you can set them up as custom commands. Custom commands come in two types:

*   **User-level commands**: Placed in `~/.claude/commands/` directory, suitable for commands common to all projects. Triggered by inputting `/user:command-name`.
*   **Project-level commands**: Placed in `.claude/commands/` directory under project root, suitable for project-specific commands. Triggered by `/project:command-name`.

**Example:**

Suppose you create an `optimize.md` file in `.claude/commands/` folder with the content:

```markdown
Please analyze and fix this GitHub Issue: $ARGUMENTS.

Follow these steps:

1. Use `gh issue view` command to view Issue details
2. Understand Issue description
3. Search for relevant files in the codebase
4. Implement necessary changes to resolve the Issue
5. Write and run tests to verify the fix
6. Ensure code passes style checks and type checking
7. Create descriptive commit message
8. Push code and create PR

Remember all GitHub-related operations use GitHub CLI tool (`gh`).
```

After saving, you can execute `/project:fix-github-issue 1234` in Claude Code to let Claude automatically fix the specified GitHub issue. Where 1234 is the Issue ID, and ARGUMENTS in the command will be automatically replaced with 1234.

You can also encapsulate other requirements as commands, such as:

*   `/user:write-tests` â†’ Generate test cases
*   `/project:lint` â†’ Format code according to team standards
*   `/user:explain` â†’ Explain complex code in plain language

## **III. Prompting & Thinking Strategies**

### **XML Tag Structured Prompts**

Claude is quite sensitive to structured language. Using XML-like block formats can significantly improve prompt clarity and controllability. Recommended structure:

```xml
<instruction>
The main task or goal you want Claude to execute
</instruction>

<context>
Background information for the task, such as involved frameworks, business logic, team standards, etc.
</context>

<code_example>
Reference code snippets, interface specifications, or existing implementations
</code_example>
```

This approach helps Claude more accurately distinguish between "**what you want it to do**" and "**what auxiliary information you've provided**", avoiding treating background as goals to execute.

### **Pre-activation: Learn First, Then Act**

Claude can learn, the key is making it **understand context first** before taking action.

For example:

If you want it to refactor a backend module, don't immediately say "refactor this code", but first let it read the entire module, analyze directory structure, summarize existing functionality, then enter the coding phase.

Step-by-step approach:

1.  Ask Claude to read specific folders (e.g., `/src/services/user/`) and output a summary;
2.  After ensuring it understands, give specific tasks, such as "migrate feature A to module B and optimize logic".

This pre-activation guidance is more reliable than directly throwing tasks at it.

### **Forced Deep Thinking**

From a prompting perspective, Claude has deep thinking mode, but it's not enabled by default. You can trigger it to enter **serious thinking** state by adding keywords.

Common keywords:

*   `think harder`
*   `ultrathink`
*   `step-by-step reasoning`

After adding these keywords, although response time is slightly longer, model output quality will significantly improve.

```text
I need to implement a new authentication system using OAuth2 for our API. Think deeply about the best approach for implementing this in our codebase. 

think about potential security vulnerabilities in this approach 

think harder about edge cases we should handle 
```

### **Provide Clear Requirement Documents**

Claude is not a copy of your brain. If your instructions are vague or incomplete, it can only guess, and the results are usually inaccurate.

Correct approach:

*   Take time to clearly write out the functionality you want it to complete;
*   Specify involved interfaces, interaction methods, boundary conditions;
*   If you can draw diagrams (flowcharts, data flow), even better.

The clearer you write, the more accurately Claude can execute; if you're vague, it can only get the gist.

## **IV. Software Development Practices**

### **Task Decomposition**

*   **Small tasks**: Send clear requirements at once, Claude can complete quickly, suitable for scenarios like "rewrite comments", "format current file".
*   **Complex tasks**: Recommend manual step breakdown, for example:

*   Step 1: Create API interface
*   Step 2: Add field validation
*   Step 3: Write test cases
*   Step 4: Write documentation or PR description
    Decomposition helps Claude focus on context, avoiding token limits or logic confusion.

### **Understanding Project Context**

Before letting Claude modify code, it's best to first let it analyze project structure. Common approaches include:

*   Paste database schema, let Claude familiarize with table structure and field types
*   Show error handling logic, authentication logic, directory structure and other core framework content
*   Use CLAUDE.md to specify style standards and dependency frameworks (such as whether to use DRF, whether to customize exception handling, etc.)

The clearer Claude's understanding, the more the generated code fits the project's current state.

### **Linux Command Assistance**

You can directly use everyday language to have Claude help write complex Linux commands. Typical examples:

*   List the top 3 Java files with the most lines in the current directory
*   Find Markdown files modified within the last 7 days
*   Batch rename files matching specific rules
*   Count the number of functions in each Python file and sort

Claude will output corresponding Bash commands and explain their meaning, suitable for script generation, automation processing, or command learning.

## **V. Cost & Model Management**

### **Model Switching**

`/model` switches between `Claude Sonnet 4` (default, cost-effective) and `Claude Opus` (Max user exclusive, more powerful).

### **Monitor Token Costs**

Use `/cost` to view consumption, including total spending, total usage time, model usage information, etc.

![Cost Monitoring](/images/claude-code-comprehensive-guide/cost-monitoring.jpg)

### **Using ccusage Consumption Monitoring**

The `/cost` function is quite limited, only showing current session consumption. Recommend using `ccusage` for more detailed monitoring.

Installation: `sudo npm install -g ccusage`

![Usage Monitoring](/images/claude-code-comprehensive-guide/ccusage-monitoring.jpg)

Other common ccusage commands:

```bash
# Basic usage  
ccusage          # Show daily report (default)  
ccusage daily    # Daily token usage and costs  
ccusage monthly  # Monthly summary report  
ccusage session  # Usage statistics by session  
ccusage blocks   # 5-hour billing window data  

# Real-time monitoring  
ccusage blocks --live  # Real-time usage dashboard  

# Filtering & options  
ccusage daily --since 20250525 --until 20250530  # Specify date range  
ccusage daily --json      # Output JSON format  
ccusage daily --breakdown # Break down costs by model
```

## **VI. Advanced Features**

### **Running Parallel Claude Code Sessions Using Git Worktrees**

When using Claude Code, if you want to handle multiple tasks and branches simultaneously while keeping each instance completely isolated, Git worktrees is a very practical solution.

Git worktree allows you to check out different branches of the same Git repository into separate directories. Each worktree has its own working directory and isolated file state, but shares the same Git history.

Official documentation: **[https://git-scm.com/docs/git-worktree](https://git-scm.com/docs/git-worktree)**

**Step 1: Create New Worktree**

If you want to create a new branch and start a new working copy:

```bash
git worktree add ../project-feature-a -b feature-a
```

If you already have an existing branch:

```bash
git worktree add ../project-bugfix bugfix-123
```

This creates an independent directory outside the project (such as `../project-feature-a`) containing the complete working directory for that branch.

**Step 2: Run Claude Code in Each Worktree**

Enter the new worktree:

```bash
cd ../project-feature-a
claude
```

Open another worktree:

```bash
cd ../project-bugfix
claude
```

Each session runs in its own independent code environment, Claude Code instances don't interfere with each other.

**Step 3: Manage Worktrees**

List all current worktrees:

```bash
git worktree list
```

Delete a worktree:

```bash
git worktree remove ../project-feature-a
```

Note: Deleting worktree doesn't delete Git branches, only cleans up directories.

Considerations:

*   Each worktree is equivalent to an independent Claude Code sandbox, suitable for parallel processing of multiple tasks (such as bug fixes, feature development, refactoring).
*   Changes in one worktree won't affect another worktree.
*   All worktrees share the same Git history and remote settings, convenient for unified pushing.
*   Use meaningful directory names (such as `project-auth`, `project-api-v2`) to help quickly distinguish tasks.
*   After creating each new worktree, must initialize development environment, for example:

*   **JavaScript projects**: npm install  
*   **Python projects**: python -m venv .venv  
    source .venv/bin/activate  
    pip install -r requirements.txt  

### **MCP**

You can integrate MCP (such as Postgres), web pages, image processing, etc. in Claude Code, enabling Claude to directly operate external systems.

**Adding MCP example:**

```bash
claude mcp add <name> <command> [args...]
# Example
claude mcp add pg-server /path/to/postgres-mcp --connection-string "postgresql://user:pass@localhost:5432/mydb"
```

**Managing MCP:**

```bash
claude mcp list             # View configured services
claude mcp get <name>       # View service details
claude mcp remove <name>    # Remove service
```

### **Claude Code GitHub Action**

Claude Code GitHub Actions is a set of AI-driven GitHub automation tools designed to seamlessly integrate Claude's code generation and collaboration capabilities into your development workflow.

![GitHub Action Integration](/images/claude-code-comprehensive-guide/github-action.jpg)

**Installation**: Execute `/install-github-app` in Claude Code and follow the setup process.

After installation, you can `@claude` in PRs or issues to have it complete specified tasks:

**Automatically generate PR through issue:**

```text
@claude implement this feature based on the issue description
```

**Request code suggestions:**

```text
@claude how should I implement user authentication for this endpoint?
```

**Fix bugs:**

```text
@claude fix the TypeError in the user dashboard component
```

**ðŸ”— Extended Reading:** [Claude Code Production Workflow](/docs/en/best-practices/claude-code-production-workflow)

### **Using Claude as Unix-like Programs**

Claude is not just an interactive AI, it can also work like a regular Unix command-line tool, integrating into your development process.

For example, you can use pipes `|` to input content to Claude:

```bash
cat build-error.txt | claude -p 'concisely explain the root cause of this build error' > output.txt
```

Besides plain text, you can also specify output formats:

**Text format (default):**

```bash
cat data.txt | claude -p 'summarize this data' --output-format text > summary.txt
```

*   Only outputs plain text content.
*   Suitable for daily conversations, summaries, explanations, etc.

**JSON format:**

```bash
cat code.py | claude -p 'analyze this code for bugs' --output-format json > analysis.json
```

*   Outputs as JSON array, including Claude's response, metadata (such as token costs, runtime, etc.).
*   Suitable for embedding results into automated processes or frontend display.

**Streaming JSON (stream-json)**

```bash
cat log.txt | claude -p 'parse this log file for errors' --output-format stream-json
```

*   Real-time line-by-line JSON message output, each line is an independent JSON object.
*   Better suited for processing large files, long outputs, or real-time monitoring scenarios.
*   Note: The entire output is not a complete JSON array, needs line-by-line processing.

You can even add Claude to build scripts as a code review tool.

```json
{
  "scripts": {
    "lint:claude": "claude -p 'you are a linter. please look at the changes vs. main and report any issues related to typos. report the filename and line number on one line, and a description of the issue on the second line. do not return any other text.'"
  }
}
```